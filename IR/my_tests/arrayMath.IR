define void :main () {
    :entry

    int64[][] %arr1
    int64[][] %arr2
    int64[][] %arr3
    int64 %offset 
    int64[][] %prod
    int64[][] %sum
    int64[][] %diff

    %offset <- 19
    %arr1 <- call :initArr(3,4, %offset)
    call :print2DArray(%arr1)
    call print(12343)

    %offset <- 3 
    %arr2 <- call :initArr(3,4, %offset)
    call :print2DArray(%arr2)
    call print(12343)

    %arr3 <- call :addArrs(%arr1, %arr2)
    call :print2DArray(%arr3)
    call print(12343)

    %arr3 <- call :multArrs(%arr1, %arr2)
    call :print2DArray(%arr3)
    call print(12343)

    return
}

define int64 :encode(int64 %n) {
    :entry
    %n <- %n << 1
    %n <- %n + 1
    return %n
}

define int64 :decode(int64 %n) {
    :entry
    %n <- %n >> 1
    return %n
}

define int64[][] :initArr(int64 %numRow, int64 %numCol, int64 %offset) {
    :entry    

    int64[][] %toReturn

    int64 %numRowEncoded
    int64 %numColEncoded
    %numRowEncoded <- call :encode(%numRow)
    %numColEncoded <- call :encode(%numCol)
    %toReturn <- new Array(%numRowEncoded, %numColEncoded)
    
    int64 %i
    %i <- 0
    br :check_loop_1_lab
    
    :check_loop_1_lab
    int64 %check_loop_1
    %check_loop_1 <- %i < %numCol
    br %check_loop_1 :loop_1_body :exit_loops

    :loop_1_body
    int64 %j
    %j <- 0
    br :check_loop_2_lab

    :check_loop_2_lab
    int64 %check_loop_2
    %check_loop_2 <- %j < %numRow
    br %check_loop_2 :loop_2_body :exit_loop_2

    :loop_2_body
    int64 %currElem
    
    %currElem <- %offset
    int64 %encoded_i
    int64 %decoded_currElem
    %encoded_i <- call :encode(%i)
    %currElem <- %offset + %encoded_i
    %currElem <- call :encode(%currElem)
    %decoded_currElem <- call :decode(%currElem)
    %currElem <- call :multiplyAndEncode(%j, %decoded_currElem)
    %toReturn[%i][%j] <- %currElem
    %j <- %j + 1
    br :check_loop_2_lab

    :exit_loop_2
    %i <- %i + 1
    br :check_loop_1_lab

    :exit_loops
    return %toReturn
}

define int64 :multiplyAndEncode (int64 %num1, int64 %num2){
    :entry
    %num1 <- %num1 * %num2 // num1 and num2 are decoded
    %num1 <- %num1 << 1
    %num1 <- %num1 + 1
    return %num1
}

// %arr1 and %arr2 must be of same dimensions
// element wise multiplication
define int64[][] :multArrs(int64[][] %arr1, int64[][] %arr2) {
    :entry    

    int64[][] %toReturn

    int64 %numRowEncoded
    int64 %numColEncoded
    int64 %numRow
    int64 %numCol
    %numRowEncoded <- length %arr1 0
    %numColEncoded <- length %arr1 1

    %numRow <- %numRowEncoded >> 1 // decode
    %numCol <- %numColEncoded >> 1 // decode
    %toReturn <- new Array(%numRowEncoded, %numColEncoded)
    
    int64 %i
    %i <- 0
    br :check_loop_1_lab
    
    :check_loop_1_lab
    int64 %check_loop_1
    %check_loop_1 <- %i < %numRow
    br %check_loop_1 :loop_1_body :exit_loops

    :loop_1_body
    int64 %j
    %j <- 0
    br :check_loop_2_lab

    :check_loop_2_lab
    int64 %check_loop_2
    %check_loop_2 <- %j < %numCol
    br %check_loop_2 :loop_2_body :exit_loop_2

    :loop_2_body
    int64 %currElem
    
    int64 %currProd
    int64 %a1
    int64 %a2
    %a1 <- %arr1[%i][%j]
    %a2 <- %arr2[%i][%j]
    %a1 <- %a1 >> 1
    %a2 <- %a2 >> 1
    %currProd <- %a1 * %a2
    %currProd <- call :encode(%currProd)
    %toReturn[%i][%j] <- %currProd
    %j <- %j + 1
    br :check_loop_2_lab

    :exit_loop_2
    %i <- %i + 1
    br :check_loop_1_lab

    :exit_loops
    return %toReturn
}

// %arr1 and %arr2 must be of same dimensions
define int64[][] :addArrs(int64[][] %arr1, int64[][] %arr2) {
    :entry    

    int64[][] %toReturn

    int64 %numRowEncoded
    int64 %numColEncoded
    int64 %numRow
    int64 %numCol
    %numRowEncoded <- length %arr1 0
    %numColEncoded <- length %arr1 1

    %numRow <- %numRowEncoded >> 1 // decode
    %numCol <- %numColEncoded >> 1 // decode
    %toReturn <- new Array(%numRowEncoded, %numColEncoded)
    
    int64 %i
    %i <- 0
    br :check_loop_1_lab
    
    :check_loop_1_lab
    int64 %check_loop_1
    %check_loop_1 <- %i < %numRow
    br %check_loop_1 :loop_1_body :exit_loops

    :loop_1_body
    int64 %j
    %j <- 0
    br :check_loop_2_lab

    :check_loop_2_lab
    int64 %check_loop_2
    %check_loop_2 <- %j < %numCol
    br %check_loop_2 :loop_2_body :exit_loop_2

    :loop_2_body
    int64 %currElem
    
    int64 %currSum
    int64 %a1
    int64 %a2
    %a1 <- %arr1[%i][%j]
    %a2 <- %arr2[%i][%j]
    %currSum <- call :encoded_add(%a1,  %a2)
    %toReturn[%i][%j] <- %currSum
    %j <- %j + 1
    br :check_loop_2_lab

    :exit_loop_2
    %i <- %i + 1
    br :check_loop_1_lab

    :exit_loops
    return %toReturn
}

define void :print2DArray(int64[][] %arr) {
    :entry
    int64 %first_dimension_length
    int64 %second_dimension_length

    %first_dimension_length <- length %arr 0 
    %second_dimension_length <- length %arr 1 

    %first_dimension_length <- %first_dimension_length >> 1 // decode
    %second_dimension_length <- %second_dimension_length >> 1 // decode

    int64 %i
    %i <- 0
    br :check_loop_1_lab
    
    :check_loop_1_lab
    int64 %check_loop_1
    %check_loop_1 <- %i =  %first_dimension_length
    br %check_loop_1 :exit_loops :loop_1_body 

    :loop_1_body
    int64 %j
    %j <- 0
    int64 %new_num_col //new num row is 3 (encoded)
    int64[] %currRow
    // encode num col
    %new_num_col <- call :encode(%second_dimension_length)
    %currRow <- new Array(%new_num_col)
    br :check_loop_2_lab

    :check_loop_2_lab
    int64 %check_loop_2
    %check_loop_2 <- %j = %second_dimension_length

    br %check_loop_2 :exit_loop2 :loop_2_body 

    :loop_2_body
    int64 %currToPrint
    
    %currToPrint <- %arr[%i][%j]
    %currToPrint <- call :encode(%currToPrint)
    %currRow[%j] <- %currToPrint
    %j <- %j + 1
    br :check_loop_2_lab

    :exit_loop2
    %i <- %i + 1
    call print(%currRow)
    br :check_loop_1_lab

    :exit_loops
    return
}

define int64 :encoded_add(int64 %a, int64 %b) {
    :entry
    %a <- %a + %b
    %a <- %a - 1
    return %a
}
